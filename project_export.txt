ЭКСПОРТ СОДЕРЖИМОГО ФАЙЛОВ ПРОЕКТА
============================================================

[ФАЙЛ 1/7]
ПУТЬ: ./Characters/character.py
----------------------------------------
# character.py
from Characters.Abilities.abilities import AbilityManager
from Config.game_config import BASE_ENERGY_COST
from .base_stats import Stats, DerivedStats

class Character:
    """Базовый класс, представляющий персонажа в игре."""
    def __init__(self, name, role, level=1, is_player=False, can_heal=False):
        
        self.name = name
        self.role = role
        self.is_player = is_player
        self.level = level
        self.alive = True
        self.can_heal = can_heal
        
        # Создаем объекты характеристик
        self.stats = Stats(self)
        self.derived_stats = DerivedStats(self.stats, self.role, self.level)
        
        # Инициализируем hp и энергию
        self.hp = self.derived_stats.max_hp
        self.energy = self.derived_stats.max_energy
        
        # Способности
        self.ability_manager = AbilityManager()
        
    @staticmethod
    def scale_stats(base_stats, level, growth_rates):
        """Масштабирует характеристики в зависимости от уровня."""
        scaled_stats = {}
        for stat, base_value in base_stats.items():
            growth_rate = growth_rates.get(stat, 0.05)
            scaled_stats[stat] = int(base_value * (1 + (level - 1) * growth_rate))
        return scaled_stats
    
    # Добавляем методы для работы со способностями
    def add_ability(self, name, ability):
        """Добавляет способность персонажу."""
        self.ability_manager.add_ability(name, ability)
        
    def get_available_abilities(self):
        """Получает список доступных способностей."""
        return self.ability_manager.get_available_abilities(self)
        
    def use_ability(self, name, targets, **kwargs):
        """Использует способность по имени."""
        return self.ability_manager.use_ability(name, self, targets, **kwargs)
        
    def update_ability_cooldowns(self):
        """Обновляет кулдауны способностей в конце раунда."""
        self.ability_manager.update_cooldowns()
        
    def take_heal(self, heal_amount):
        old_hp = self.hp
        self.hp = min(self.derived_stats.max_hp, self.hp + int(heal_amount))
        return self.hp - old_hp

    def take_damage(self, damage):
        """Наносит урон персонажу, учитывая защиту."""
        self.hp -= damage
        if self.hp <= 0:
            self.hp = 0
            self.alive = False
        return True
        
    def is_alive(self):
        """Проверяет, жив ли персонаж."""
        return self.alive
        
    def get_level(self):
        """Возвращает уровень персонажа."""
        return self.level
        
    def restore_energy(self, amount=None, percentage=None):
        """
        Восстанавливает энергию персонажа.
        :param amount: конкретное количество энергии для восстановления
        :param percentage: процент от максимальной энергии для восстановления
        """
        if percentage is not None:
            # Восстанавливаем указанный процент от максимальной энергии
            restore_amount = int(self.derived_stats.max_energy * (percentage / 100))
            self.energy = min(self.derived_stats.max_energy, self.energy + restore_amount)
        elif amount is not None:
            # Восстанавливаем конкретное количество энергии
            self.energy = min(self.derived_stats.max_energy, self.energy + amount)
        else:
            # Полное восстановление
            self.energy = self.derived_stats.max_energy
            
    def spend_energy(self, amount=BASE_ENERGY_COST):
        self.energy -= amount
----------------------------------------
КОНЕЦ ФАЙЛА: ./Characters/character.py
============================================================

[ФАЙЛ 2/7]
ПУТЬ: ./Characters/base_mechanics.py
----------------------------------------
# mechanics.py
import random
#from config import Config

def calculate_dodge_chance(target):
    """
    Рассчитывает шанс уклонения от атаки на основе ловкости цели.
    :param target: Персонаж, от которого пытается уклониться атака.
    :return: Вероятность уклонения (float от 0.0 до 1.0).
    """
    # Базовый шанс уклонения 5%
    base_dodge = 0.05
    # Бонус к уклонению: +1% за каждые 2 единицы ловкости сверх 10
    dex_bonus = max(0, (target.dexterity - 10) * 0.005) # +0.5% за каждую единицу dex > 10

    # Максимальный шанс уклонения 30%
    return min(0.30, base_dodge + dex_bonus)

def calculate_crit_chance(character, is_heal=False):
    """
    Рассчитывает шанс критического эффекта (удара или лечения) на основе ловкости персонажа.
    :param character: Персонаж, применяющий эффект.
    :param is_heal: Флаг, указывающий, является ли эффект лечением (по умолчанию False для атаки).
    :return: Вероятность критического эффекта (float от 0.0 до 1.0).
    """
    # Только игроки могут наносить криты
    if not hasattr(character, 'dexterity') or character.role == "enemy":
        return 0.0
        
    # Базовый шанс крита 5%
    base_crit = 0.05
    # Бонус к криту: +1% за каждую единицу ловкости сверх 10
    dex_bonus = max(0, (character.dexterity - 10) * 0.01)
    
    # Максимальный шанс крита 50%
    return min(0.50, base_crit + dex_bonus)

def perform_attack(attacker, target, battle_logger):
    """
    Выполняет атаку одного персонажа по другому с учетом уклонения и критических ударов.
    
    :param attacker: Персонаж, атакующий.
    :param target: Персонаж, цель атаки.
    :param battle_logger: Экземпляр BattleLogger для логирования.
    """
    # Проверка уклонения
    dodge_chance = calculate_dodge_chance(target)
    if random.random() < dodge_chance:
        # Цель уклоняется
        #combat_stats.record_damage_dealt(attacker.name, 0) # Записываем 0 урона как попытку атаки
        
        # Определяем эмодзи и тип сообщения для battle_logger
        message = f"{attacker.name} атакует {target.name}, но {target.name} УКЛОНИЛСЯ!"
        battle_logger.log_combat_result(message)
        return # Атака не попала, выходим из функции

    # --- Атака попала ---
    # Базовый урон
    base_damage = random.randint(attacker.attack // 2, attacker.attack)
    
    # Проверка критического удара
    is_critical = False
    crit_multiplier = 1.5
    final_damage = base_damage
    
    # Используем универсальную функцию для атаки (is_heal=False по умолчанию)
    crit_chance = calculate_crit_chance(attacker)
    if random.random() < crit_chance:
        is_critical = True
        final_damage = int(base_damage * crit_multiplier)
    
    # Наносим урон и расходуем энергию
    #combat_stats.record_damage_dealt(attacker.name, final_damage)
    dealt, blocked = target.take_damage(final_damage)
    attacker.spend_energy() #расход энергии на атаку
    
    # Формируем сообщение
    blocked_text = f" ({blocked} заблокировано)" if blocked > 0 else ""
    
    if is_critical:
        # Яркое отображение критического удара
        message = f"{attacker.name} наносит КРИТИЧЕСКИЙ УДАР по {target.name}! Урон: {dealt}!{blocked_text}"
        battle_logger.log_combat_result(message) # Используем специализированный метод для крит. ударов
    else:
        message = f"{attacker.name} атакует {target.name} и наносит {dealt} урона!{blocked_text}"
        battle_logger.log_combat_result(message) # Используем специализированный метод для атак
        
    if not target.is_alive():
        #combat_stats.record_kill(attacker.name)
        #combat_stats.record_death(target.name)
        message = f"{target.name} повержен!"
        battle_logger.log_death(message) # Используем специализированный метод для смерти

# === Функции для лечения ===
def execute_heal_ability(healer, target_ally, heal_amount_base, battle_logger):
    """
    Выполняет способность лечения с возможностью критического лечения.
    
    :param healer: Персонаж, применяющий лечение.
    :param target_ally: Цель лечения (союзник).
    :param heal_amount_base: Базовое количество лечения.
    :param battle_logger: Экземпляр BattleLogger для логирования.
    """
    # Случайное значение лечения вокруг базового
    base_heal_amount = random.randint(heal_amount_base - 5, heal_amount_base + 5)
    
    # Проверка критического лечения
    is_heal_critical = False
    heal_crit_multiplier = 2
    final_heal_amount = base_heal_amount
    
    # Используем универсальную функцию для лечения (is_heal=True)
    heal_crit_chance = calculate_crit_chance(healer, is_heal=True)
    if random.random() < heal_crit_chance:
        is_heal_critical = True
        final_heal_amount = int(base_heal_amount * heal_crit_multiplier)
    
    # Записываем статистику ДО применения лечения
    #combat_stats.record_healing_done(healer.name, final_heal_amount)
    #combat_stats.record_healing_taken(target_ally.name, final_heal_amount)
    
    # Применяем лечение
    old_hp = target_ally.hp
    target_ally.hp = min(target_ally.derived_stats.max_hp, target_ally.hp + final_heal_amount)
    actual_heal = target_ally.hp - old_hp # Реальное количество восстановленных HP
    
    # Выводим сообщение в лог
    if is_heal_critical:
        # Яркое отображение критического лечения
        message = f"{healer.name} применяет КРИТИЧЕСКОЕ ЛЕЧЕНИЕ на {target_ally.name}! Восстановлено: {actual_heal} HP!"
        battle_logger.log_heal(message) # Используем специализированный метод для крит. лечения
    else:
        message = f"{healer.name} использует способность и лечит {target_ally.name} на {actual_heal} HP"
        battle_logger.log_heal(message) # Используем специализированный метод для лечения

def execute_mass_heal_ability(healer, allies_list, heal_amount_base, battle_logger):
    """
    Выполняет массовое лечение всех союзников с возможностью критического лечения.
    
    :param healer: Персонаж, применяющий лечение.
    :param allies_list: Список союзников для лечения.
    :param heal_amount_base: Базовое количество лечения.
    :param battle_logger: Экземпляр BattleLogger для логирования.
    """
    # Фильтруем только живых союзников СРАЗУ
    alive_allies = [ally for ally in allies_list if ally.is_alive()]
    
    if not alive_allies:
        message = f"{healer.name} пытается применить массовое лечение, но нет живых союзников!"
        battle_logger.log_heal(message)
        return
    
    # Распределяем лечение между живыми союзниками
    heal_per_target = heal_amount_base // len(alive_allies)
    heal_per_target = max(1, heal_per_target)  # Минимум 1
    
    # Случайное значение лечения вокруг базового на цель
    try:
        base_heal_amount = random.randint(int(heal_per_target) - 3, int(heal_per_target) + 3)
        base_heal_amount = max(1, base_heal_amount)  # Минимум 1
    except ValueError:
        # Если диапазон неверный, используем базовое значение
        base_heal_amount = max(1, int(heal_per_target))
    
    # Проверка критического лечения (один шанс на все цели)
    is_heal_critical = False
    heal_crit_multiplier = 1.8  # Меньше, чем у одиночного лечения
    final_heal_amount = base_heal_amount
    
    # Используем универсальную функцию для лечения (is_heal=True)
    heal_crit_chance = calculate_crit_chance(healer, is_heal=True) * 0.7  # Меньше шанс крита для массового
    if random.random() < heal_crit_chance:
        is_heal_critical = True
        final_heal_amount = int(base_heal_amount * heal_crit_multiplier)
    
    total_healed = 0
    individual_heals = []  # Сохраняем индивидуальное лечение для точного подсчета
    
    # Лечим каждого союзника и сохраняем реальное лечение
    for target_ally in alive_allies:
        # Записываем статистику ДО применения лечения
        #combat_stats.record_healing_done(healer.name, final_heal_amount)
        #combat_stats.record_healing_taken(target_ally.name, final_heal_amount)
        
        # Применяем лечение
        old_hp = target_ally.hp
        target_ally.hp = min(target_ally.derived_stats.max_hp, target_ally.hp + final_heal_amount)
        actual_heal = target_ally.hp - old_hp  # Реальное количество восстановленных HP
        
        individual_heals.append((target_ally.name, actual_heal))
        total_healed += actual_heal
    
    # Выводим сообщение в лог
    crit_text = "КРИТИЧЕСКОЕ " if is_heal_critical else ""
    crit_emoji = "✨" if is_heal_critical else ""
    
    message = f"{healer.name} применяет {crit_text}МАССОВОЕ ЛЕЧЕНИЕ! Восстановлено {total_healed} HP у {len(alive_allies)} союзников!"
    battle_logger.log_heal(message) # Используем специализированный метод для массового лечения
    
    # Подробная информация о лечении каждого персонажа
    for ally_name, actual_heal in individual_heals:
        if actual_heal > 0:
            message = f"   {ally_name}: +{actual_heal} HP"
            battle_logger.log_heal(message) # Используем специализированный метод для деталей лечения

def perform_rest(character, battle_logger):
    """
    Выполняет действие отдыха для персонажа.
    Восстанавливает фиксированное количество энергии.
    
    :param character: Персонаж, который отдыхает.
    :param battle_logger: Экземпляр BattleLogger для логирования.
    """
    
    # Восстанавливаем энергию
    RESTORE_ENERGY_AMOUNT = 30
    character.restore_energy(amount=RESTORE_ENERGY_AMOUNT)
    
    # Формируем сообщение
    message = f"{character.name} отдыхает и восстанавливает {RESTORE_ENERGY_AMOUNT} энергии"
    battle_logger.log(message, character=character)

----------------------------------------
КОНЕЦ ФАЙЛА: ./Characters/base_mechanics.py
============================================================

[ФАЙЛ 3/7]
ПУТЬ: ./Battle/battle_logic.py
----------------------------------------

import uuid
from Battle.battle_logger import battle_logger
from Battle.battle_statistics import get_battle_statistics
from Battle.round_logic import battle_round, display_round_separator
from Battle.rewards import BattleRewards
from Config.game_config import MAX_ROUNDS
from Inventory.inventory import get_inventory

def pre_battle_setup(players, enemies) -> None:
    """
    Выполняет подготовку перед началом боя.
    
    :param players: Список игроков
    :param enemies: Список врагов
    """
    # TODO: Добавить логику подготовки перед боем
    # Например:
    # - Проверка состояния персонажей
    # - Инициализация специальных эффектов
    # - Подготовка окружения боя
    # - Отображение информации о противниках
    pass

def simulate_battle(players, enemies) -> str:
    """
    Симулирует бой между игроками и врагами.
    
    :return: Результат битвы ("win", "loss", или "draw")
    """
    # Подготовка перед боем
    pre_battle_setup(players, enemies)
    
    # Начало боя
    battle_logger.log("")
    battle_logger.log("🏁 БОЙ НАЧИНАЕТСЯ!")
    battle_result = "draw"  # По умолчанию - ничья
    
    #начало записи статистики
    battle_id = str(uuid.uuid4())
    stats = get_battle_statistics()
    stats.start_battle_tracking(battle_id, players, enemies)

    # Основной цикл боя
    for round_num in range(1, MAX_ROUNDS + 1):
        
        display_round_separator(round_num)
        round_result = battle_round(players, enemies, battle_logger)
        
        if round_result == "win" or round_result == "loss":
            battle_result = round_result
            break  # Заканчиваем бой
        
        if round_num == MAX_ROUNDS:
            battle_logger.log(f"⏳ Время вышло! Раунд {round_num} стал последним.")

    # Все действия после боя
    # В конце битвы просто сохраняем итоги
    #Статистика после боя
    stats.end_battle(battle_id, True, 1)

    post_battle_processing(players, enemies, battle_result)
    
    return battle_result

def post_battle_processing(players, enemies, battle_result) -> None:
    """
    Выполняет все действия после завершения боя.
    
    :param players: Список игроков
    :param enemies: Список врагов
    :param battle_result: Результат боя ("win", "loss", "draw")
    """
    # Начисляем награды при победе
    if battle_result == "win":
        
        battle_logger.set_message_delay(0)

        battle_logger.log(f"🎖️ ПОБЕДА! Все враги повержены!")
        award_rewards(players, enemies)
        # Восстановление энергии всем выжившим игрокам
        restore_energy_after_battle([p for p in players if p.is_alive()])

        battle_logger.set_message_delay()
    
    # Сброс кулдаунов всех способностей у всех персонажей
    reset_all_cooldowns(players + enemies)

def award_rewards(players, defeated_enemies) -> None:
    """
    Начисляет награды игрокам за победу в бою.
    
    :param players: Список игроков
    :param defeated_enemies: Список побежденных врагов
    """
    if not defeated_enemies:
        return
    
    # Распределяем награды между выжившими игроками
    alive_players = [p for p in players if p.is_alive()]
    
    if not alive_players:
        return
    
    # Получаем награды
    reward_results = BattleRewards.distribute_rewards(defeated_enemies, alive_players)
    
    # Выводим сообщения о наградах
    for message in reward_results['messages']:
        battle_logger.log(message)

    for message in reward_results['level_up_messages']:
        battle_logger.log(message)

def restore_energy_after_battle(players) -> None:
    """
    Восстанавливает 30% максимальной энергии всем выжившим игрокам после боя.
    
    :param players: Список игроков
    """
    for player in players:
        if player.is_alive():
            player.restore_energy(percentage=30)
    
    #battle_logger.log(f"🧘 Команда восстанавливает часть энергии после боя")

def reset_all_cooldowns(characters) -> None:
    """
    Сбрасывает все кулдауны способностей у всех персонажей.
    
    :param characters: Список персонажей
    """
    for character in characters:
        if hasattr(character, 'ability_manager'):
            character.ability_manager.reset_all_cooldowns()
----------------------------------------
КОНЕЦ ФАЙЛА: ./Battle/battle_logic.py
============================================================

[ФАЙЛ 4/7]
ПУТЬ: ./Battle/round_logic.py
----------------------------------------
import random
from xxlimited import Str
from Battle.battle_logger import battle_logger
from Battle.battle_statistics import CombatActionRecord, get_battle_statistics
from Characters.behavior import decide_action

def battle_round(players, enemies, battle_logger) -> str:
    """Один раунд боя"""
    
    battle_result = None

    # --- Ход игроков ---
    for player in players:
        if not player.is_alive():
            continue

        # Используем логику поведения для принятия решения
        action_result = decide_action(player, players, [e for e in enemies if e.is_alive()])
        log_result(action_result)

        # Простая проверка победы после каждого действия игрока
        if all(not e.is_alive() for e in enemies):
            return "win" # Возвращаем результат

    # --- Ход врагов ---
    for enemy in enemies:
        if not enemy.is_alive():
            continue

        # Используем логику поведения для принятия решения
        action_result = decide_action(enemy, enemies, [p for p in players if p.is_alive()])
        log_result(action_result)

        # Простая проверка поражения после каждого действия врага
        if all(not p.is_alive() for p in players):
            battle_logger.log("☠️ ПОРАЖЕНИЕ! Вся команда погибла...")
            battle_result = "loss"
            return battle_result # Возвращаем результат
        
    # Обновляем кулдауны способностей
    for player in players:
            player.ability_manager.update_cooldowns()
    
    for enemy in enemies:
            enemy.ability_manager.update_cooldowns()
    
    # В любом случае завершаем бой без вывода статистики
    return battle_result # Возвращаем результат

def log_result(action_result) -> None:

    if action_result:
        #Статистика
        stats = get_battle_statistics()
        action_record = CombatActionRecord.from_ability_result(action_result)
        stats.add_combat_action(action_record) 

        for message in action_result.messages:
            battle_logger.log(message)
    else:
        battle_logger.log_enemy_action("что-то не так при использовании способности")

def display_round_separator(round_num):
    """Отображает красивый разделитель раундов"""
    battle_logger.log("") # Пустая строка перед новым раундом
    #separator = f"◦•●◉✿◉●•◦•●◉✿◉●•◦•●◉✿◉●•(раунд: {round_num})•●◉✿◉●•◦•●◉✿◉●•◦•●◉✿◉●•◦"
    separator = [
    ("◦", 1), ("•", 2), ("●", 3), ("◉", 4), ("✿", 5), ("◉", 4), ("●", 3), ("•", 2), ("◦", 1),
    ("•", 6), ("●", 1), ("◉", 2), ("✿", 3), ("◉", 4), ("●", 5), ("•", 6), ("◦", 1),
    ("•", 2), ("●", 3), ("◉", 4), ("✿", 5), ("◉", 4), ("●", 3), ("•", 2), ("◦", 1),
    (f"(раунд: {round_num})", 8),  # Желтый цвет для основного текста
    ("•", 6), ("●", 1), ("◉", 2), ("✿", 3), ("◉", 4), ("●", 5), ("•", 6), ("◦", 1),
    ("•", 2), ("●", 3), ("◉", 4), ("✿", 5), ("◉", 4), ("●", 3), ("•", 2), ("◦", 1),
    ("•", 6), ("●", 1), ("◉", 2), ("✿", 3), ("◉", 4), ("●", 5), ("•", 6), ("◦", 1)
    ]
    
    battle_logger.log(separator)
----------------------------------------
КОНЕЦ ФАЙЛА: ./Battle/round_logic.py
============================================================

[ФАЙЛ 5/7]
ПУТЬ: ./Characters/base_stats.py
----------------------------------------
# base_stats.py

class Stats:
    """Класс для управления базовыми характеристиками персонажа."""
    
    # Множители защиты по ролям
    DEFENSE_MULTIPLIERS = {
        "tank": 1.0,
        "warrior": 0.66,
        "healer": 0.6,
        "archer": 0.44,
        "rogue": 0.375,
        "mage": 0.285
    }
    
    # Множители атаки по ролям
    PRIMARY_STAT_MULTIPLIERS = {
        "tank": 0.8,      # Танки используют силу
        "warrior": 1.0,   # Воины используют силу
        "rogue": 1.2,     # Разбойники используют ловкость
        "archer": 1.1,    # Лучники используют ловкость
        "mage": 1.3,      # Маги используют интеллект
        "healer": 0.6     # Лекари используют интеллект (низкая атака)
    }
    
    def __init__(self, character):

        rates = character.BASE_STATS

        for stat_name, default_value in rates.items():
            setattr(self, stat_name, default_value)
    
    def get_primary_stat_for_role(self, role):
        """Возвращает основную характеристику для данной роли."""
        if role in ["tank", "warrior"]:
            return self.strength
        elif role in ["rogue", "archer"]:
            return self.dexterity
        elif role in ["mage", "healer"]:
            return self.intelligence
        else:
            return self.strength
    
    def scale_stats(self, base_stats, level, growth_rates):
        """Масштабирует характеристики в зависимости от уровня."""
        scaled_stats = {}
        for stat, base_value in base_stats.items():
            growth_rate = growth_rates.get(stat, 0.05)
            scaled_stats[stat] = int(base_value * (1 + (level - 1) * growth_rate))
        return scaled_stats
    
    def update_from_scaled_stats(self, scaled_stats):
        """Обновляет характеристики из масштабированных значений."""
        stat_names = ['dexterity', 'constitution', 'strength', 'intelligence']
        for stat_name in stat_names:
            if stat_name in scaled_stats:
                setattr(self, stat_name, scaled_stats[stat_name])


class DerivedStats:
    """Класс для управления зависимыми характеристиками персонажа."""
    
    def __init__(self, stats, role, level):
        self.max_hp = 0
        self.max_energy = 0
        self.attack = 0
        self.defense = 0
        self.calculate_all(stats, level, role)
    
    def calculate_all(self, stats, level, role):
        """Пересчитывает все зависимые характеристики."""

        dm = stats.DEFENSE_MULTIPLIERS
        psm = stats.PRIMARY_STAT_MULTIPLIERS

        self.max_hp = self.calculate_max_hp(level, stats)
        self.max_energy = self.calculate_max_energy(stats)
        self.attack = self.calculate_attack(role, stats, psm)
        self.defense = self.calculate_defense(role, stats, dm)
    
    def update_level(self, character):
        """Обновляет уровень и пересчитывает характеристики."""
        self.calculate_all(character.stats, character.level, character.role)

    def calculate_defense(self, role, stats, dm):
        """Рассчитывает защиту на основе телосложения и роли."""
        base_defense = int(stats.constitution * 1.0)
        multiplier = dm.get(role, 0.5)
        return int(base_defense * multiplier)
    
    def calculate_attack(self, role, stats, psm):
        """Рассчитывает атаку на основе основной характеристики роли."""
        # Определяем основную характеристику для атаки по роли
        if role in ["rogue", "archer"]:
            primary_stat = stats.dexterity
        else:
            primary_stat = stats.strength  # По умолчанию
            
        multiplier = 1 #psm.get(role, 0.8)
        return int(primary_stat * multiplier)
    
    def calculate_max_hp(self, level, stats):
        """Рассчитывает максимальное количество HP на основе телосложения."""
        return int(stats.constitution * 10 + level * 5)
    
    def calculate_max_energy(self, stats):
        """Рассчитывает максимальное количество энергии."""
        #TODO: переделать. у магов получается мало энергии
        return 50 + int(stats.dexterity * 7 + stats.constitution * 2)
----------------------------------------
КОНЕЦ ФАЙЛА: ./Characters/base_stats.py
============================================================

[ФАЙЛ 6/7]
ПУТЬ: ./Battle/base_mechanics.py
----------------------------------------
import random
from Battle.battle_logger import battle_logger

class GameMechanics:
    """Базовые игровые механики."""
    
    @staticmethod
    def calculate_dodge_chance(target):
        """
        Рассчитывает шанс уклонения от атаки на основе ловкости цели.
        :param target: Персонаж, от которого пытается уклониться атака.
        :return: Вероятность уклонения (float от 0.0 до 1.0).
        """
        # Базовый шанс уклонения 5%
        base_dodge = 0.05
        # Бонус к уклонению: +1% за каждые 2 единицы ловкости сверх 10
        dex_bonus = max(0, (target.stats.dexterity - 10) * 0.005) # +0.5% за каждую единицу dex > 10
        
        # Максимальный шанс уклонения 30%
        return min(0.30, base_dodge + dex_bonus)
    
    @staticmethod
    def calculate_crit_chance(character):
        """
        Рассчитывает шанс критического эффекта (удара или лечения) на основе ловкости персонажа.
        :param character: Персонаж, применяющий эффект.
        :return: Вероятность критического эффекта (float от 0.0 до 1.0).
        """
        # Базовый шанс крита 5%
        base_crit = 0.05
        # Бонус к криту: +1% за каждую единицу ловкости сверх 10
        crit_bonus = max(0, (character.stats.dexterity - 10) * 0.01)
        
        #TODO: пока делаем крит как решение в лоб - надо переделать
        a = 0
        crit_ability = character.ability_manager.get_passive_ability('criticalstrike')
        if crit_ability:
            ability_effect = crit_ability.apply_effect(character)
            crit_bonus += ability_effect['critical_bonus']
        # Максимальный шанс крита 50%
        return min(0.50, base_crit + crit_bonus)
    
    @staticmethod
    def calculate_damage_variance(base_damage, variance_percent=0.1):
        """
        Рассчитывает случайное отклонение урона.
        :param base_damage: Базовый урон
        :param variance_percent: Процент отклонения (по умолчанию 10%)
        :return: Финальный урон с учетом вариации
        """
        min_damage = base_damage * (1 - variance_percent)
        max_damage = base_damage * (1 + variance_percent)
        return random.uniform(min_damage, max_damage)
    
    @staticmethod
    def calculate_armor_reduction(damage, armor):
        """
        Рассчитывает снижение урона броней с плавной S-образной кривой.
        :param damage: Исходный урон
        :param armor: Показатель брони
        :return: Урон после снижения броней
        """
        if armor <= 0:
            return damage
        
        # S-образная кривая (сигмоид) для плавного масштабирования
        # k - коэффициент крутизны кривой (меньше значение = более плавная кривая)
        k = 0.03
        armor_effectiveness = 1 / (1 + 2.718 ** (-k * (armor - 50)))  # Сигмоид с центром в 50
        # Ограничиваем эффективность (максимум 85% блокировки)
        armor_effectiveness = min(armor_effectiveness, 0.85)
        reduced_damage = damage * (1 - armor_effectiveness)
        # Урон не может быть меньше 1
        return max(1, int(reduced_damage)), int(damage - reduced_damage)
    
    @staticmethod
    def check_dodge_with_message(attacker, target):
        """
        Проверяет, удалось ли персонажу уклониться и генерирует сообщение.
        :param attacker: Атакующий персонаж
        :param target: Цель, которая пытается уклониться
        :return: Кортеж (успешно_уклонился: bool, сообщение: list)
        """
        dodge_chance = GameMechanics.calculate_dodge_chance(target)
        dodge_success = random.random() < dodge_chance
        
        if dodge_success:
            # Генерируем сообщение об уклонении
            icon = "🏃"

            template = "%1 %2 атакует %3, но тот уклоняется!"
            if attacker.is_player:
                elements = [(icon, 0), (attacker.name, 2), (target.name, 4)]
            else:
                elements = [(icon, 0), (attacker.name, 4), (target.name, 2)]
            message = battle_logger.create_log_message(template, elements)
        else:
            message = None
            
        return dodge_success, message
    
    @staticmethod
    def check_critical(character):
        """
        Проверяет, был ли эффект критическим.
        :param character: Персонаж, применяющий эффект
        :return: True если критический эффект, False если нет
        """
        crit_chance = GameMechanics.calculate_crit_chance(character)
        return random.random() < crit_chance
    
    @staticmethod
    def apply_all_mechanics(ability, attacker, target, base_damage):
        """
        Применяет все базовые игровые механики последовательно.
        :param attacker: Атакующий персонаж
        :param target: Цель атаки
        :param base_damage: Базовый урон
        :return: Словарь с результатами всех проверок и финальным уроном
        """
        results = {
            'dodge_success': False,
            'dodge_message': None,
            'critical_hit': False,
            'base_damage': base_damage,
            'varied_damage': 0,
            'blocked_damage': 0,
            'reduced_damage': 0,
            'final_damage': 0
        }
        
        # Проверка критического удара
        results['critical_hit'] = GameMechanics.check_critical(attacker)
        crit_multiplier = 2.0 if results['critical_hit'] else 1.0
        
        # Применение вариации урона/хила
        results['varied_damage'] = GameMechanics.calculate_damage_variance(base_damage)
        damage_after_variance = results['varied_damage'] * crit_multiplier
        results['final_damage'] = int(damage_after_variance)
        
        if ability.type == 0: #(проверяем только атаки)
            
            # Проверка уклонения с генерацией сообщения
            dodge_success, dodge_message = GameMechanics.check_dodge_with_message(attacker, target)
            results['dodge_success'] = dodge_success
            results['dodge_message'] = dodge_message
            
            if dodge_success:
                results['final_damage'] = 0
                return results
        
            # Применение брони
            defence = target.derived_stats.defense
            if defence > 0:
                results['reduced_damage'], results['blocked_damage'] = GameMechanics.calculate_armor_reduction(
                    damage_after_variance, defence)
            else:
                results['reduced_damage'] = damage_after_variance
            
            results['final_damage'] = max(0, round(results['reduced_damage']))
        
        return results
    
    @staticmethod
    def get_mechanics_summary():
        """
        Возвращает описание всех доступных механик.
        :return: Словарь с описанием механик
        """
        return {
            'dodge': 'Расчет шанса уклонения от атаки',
            'crit': 'Расчет шанса критического удара',
            'variance': 'Случайное отклонение урона',
            'armor': 'Снижение урона броней',
            'all': 'Применение всех механик последовательно'
        }
----------------------------------------
КОНЕЦ ФАЙЛА: ./Battle/base_mechanics.py
============================================================

[ФАЙЛ 7/7]
ПУТЬ: ./Characters/Abilities/abilities.py
----------------------------------------
# Characters/Abilities/ability_base.py - Базовые классы способностей

import os
import re
import importlib.util
from abc import ABC, abstractmethod
from typing import Dict, List, Any, Optional, Union
from Config.game_config import ABILITIES_PATH


class AbilityResult:
    """Простой класс для возврата результатов из способностей."""
    
    def __init__(self) -> None:
        # Универсальные свойства для всех способностей
        self.success: bool = True
        self.ability_type: str = ""
        self.character: str = ""
        self.targets: List[str] = []
        self.messages: List[Any] = []
        self.damage_dealt: int = 0
        self.heal_amount: int = 0
        self.energy_restored: int = 0
        self.is_critical: bool = False
        self.total_damage: int = 0
        self.total_heal: int = 0
        self.reason: str = ""  # Причина неудачи
        self.details: Dict[str, Any] = {}  # Для дополнительной информации

class Ability(ABC):
    """Абстрактный базовый класс для способностей - нельзя создавать напрямую"""
    
    def __init__(self, name: str, type: int = 0, description: str = "", icon: str = "") -> None:
        """
        Инициализация способности.
        
        :param name: Название способности
        :param type: Тип способности - 0 - атака, 1 - лечение, 2 - отдых и т.д.
        :param description: Описание способности
        :param icon: Иконка способности
        """
        self.name: str = name
        self.type: int = type
        self.level: int = 0  # Уровень способности (0 = недоступна)
        self.description: str = description
        self.icon: str = icon
    
    def level_up(self) -> int:
        """Повышает уровень способности на 1"""
        self.level += 1
        return self.level
    
    def set_level(self, level: int) -> int:
        """Устанавливает уровень способности"""
        self.level = max(0, level)  # Уровень не может быть меньше 0
        return self.level
    
    def is_available(self) -> bool:
        """Проверяет, доступна ли способность (уровень > 0)"""
        return self.level > 0
    
    def get_info(self) -> Dict[str, Any]:
        """Возвращает информацию о способности."""
        return {
            'name': self.name,
            'type': self.type,
            'description': self.description,
            'level': self.level
        }
    
    @abstractmethod
    def can_use(self, character: Any, targets: Optional[List[Any]] = None) -> bool:
        """Абстрактный метод проверки возможности использования"""
        pass
    
    @abstractmethod
    def use(self, character: Any, targets: List[Any], **kwargs: Any) -> AbilityResult:
        """Абстрактный метод использования способности"""
        pass

class ActiveAbility(Ability):
    """Активная способность - может быть использована игроком"""
    
    def __init__(self, name: str, type: int = 0, damage_scale: float = 0.0, cooldown: int = 1, 
                 energy_cost: int = 0, description: str = "", icon: str = "", is_mass: bool = False) -> None:
        """
        Инициализация активной способности.
        
        :param name: Название способности
        :param type: Тип способности - 0 - атака, 1 - лечение, 2 - отдых и т.д.
        :param damage_scale: Процент урона от атаки владельца
        :param cooldown: Количество раундов до восстановления способности
        :param energy_cost: Стоимость энергии для использования
        :param description: Описание способности
        :param icon: Иконка способности
        :param is_mass: Массовая способность
        """
        super().__init__(name, type, description, icon)
        self.damage_scale: float = damage_scale
        self.energy_cost: int = energy_cost
        self.is_mass: bool = is_mass
        self.cooldown: int = cooldown
        self.current_cooldown: int = 0
    
    def can_use(self, character: Any, targets: Optional[List[Any]] = None) -> bool:
        """
        Проверяет, может ли персонаж использовать активную способность.
        
        :param character: Персонаж, который хочет использовать способность
        :param targets: Цели (опционально)
        :return: True, если можно использовать, иначе False
        """
        # Проверяем уровень способности
        if self.level <= 0:
            return False
            
        # Проверяем кулдаун
        if self.current_cooldown > 0:
            return False
            
        # Проверяем энергию
        if hasattr(character, 'energy') and character.energy < self.energy_cost:
            return False
            
        # Проверяем специфические условия для способности
        return self.check_specific_conditions(character, targets or [])
    
    def check_specific_conditions(self, character: Any, targets: List[Any]) -> bool:
        """
        Проверяет специфические условия для использования способности.
        Переопределяется в подклассах.
        """
        return True
    
    def use(self, character: Any, targets: List[Any], **kwargs: Any) -> AbilityResult:
        """
        Использует активную способность.
        
        :param character: Персонаж, использующий способность
        :param targets: Список целей
        :param kwargs: Дополнительные параметры
        :return: Результат использования способности
        """
        if not self.can_use(character, targets):
            result = AbilityResult()
            result.success = False
            result.reason = "Невозможно использовать способность"
            result.ability_type = self.__class__.__name__.lower()
            result.character = character.name if hasattr(character, 'name') else str(character)
            return result
        
        # Тратим энергию
        if hasattr(character, 'energy'):
            character.energy -= self.energy_cost
            
        # Запускаем кулдаун
        self.current_cooldown = self.cooldown
        
        # Выполняем способность
        result = self.execute(character, targets, **kwargs)
        
        # Обновляем статистику использования
        self.on_use(character, targets, result)
        
        return result
    
    def execute(self, character: Any, targets: List[Any], **kwargs: Any) -> AbilityResult:
        """
        Выполняет логику способности. Переопределяется в подклассах.
        """
        raise NotImplementedError("Метод execute должен быть реализован в подклассе")
    
    def update_cooldown(self) -> None:
        """Обновляет кулдаун способности в конце раунда."""
        if self.current_cooldown > 0:
            self.current_cooldown -= 1
    
    def on_use(self, character: Any, targets: List[Any], result: AbilityResult) -> None:
        """
        Вызывается после использования способности.
        Можно использовать для обновления статистики и т.д.
        """
        pass
    
    def get_info(self) -> Dict[str, Any]:
        """Возвращает информацию о активной способности."""
        info = super().get_info()
        info.update({
            'damage_scale': self.damage_scale,
            'energy_cost': self.energy_cost,
            'is_mass': self.is_mass,
            'cooldown': self.cooldown,
            'current_cooldown': self.current_cooldown
        })
        return info

class PassiveAbility(Ability):
    """Пассивная способность - работает автоматически, не требует активации"""
    
    def __init__(self, name: str, type: int = 0, description: str = "", icon: str = "") -> None:
        """
        Инициализация пассивной способности.
        
        :param name: Название способности
        :param type: Тип способности
        :param description: Описание способности
        :param icon: Иконка способности
        """
        super().__init__(name, type, description, icon)
    
    def can_use(self, character: Any, targets: Optional[List[Any]] = None) -> bool:
        """
        Пассивные способности всегда доступны если имеют уровень > 0.
        Используются автоматически системой.
        """
        return self.is_available()
    
    def use(self, character: Any, targets: List[Any], **kwargs: Any) -> AbilityResult:
        """
        Пассивные способности не могут быть использованы напрямую.
        """
        result = AbilityResult()
        result.success = False
        result.reason = "Пассивные способности нельзя использовать напрямую"
        result.ability_type = self.__class__.__name__.lower()
        result.character = character.name if hasattr(character, 'name') else str(character)
        return result
    
    def apply_effect(self, character: Any, **kwargs: Any) -> Any:
        """
        Применяет эффект пассивной способности.
        Переопределяется в подклассах.
        """
        raise NotImplementedError("Метод apply_effect должен быть реализован в подклассе")

# === Singleton AbilityLoader ===

class AbilityLoader:
    _instance: Optional['AbilityLoader'] = None
    _initialized: bool = False
    
    def __new__(cls, root_folder: Optional[str] = None) -> 'AbilityLoader':
        if cls._instance is None:
            cls._instance = super(AbilityLoader, cls).__new__(cls)
        return cls._instance
    
    def __init__(self, root_folder: Optional[str] = None) -> None:
        # Инициализируем только один раз
        if not self._initialized:
            self.root_folder: str = root_folder or 'Characters/Abilities'
            self._class_map: Dict[str, type] = {}  # Теперь храним классы, а не пути
            self._scan_abilities()
            self.__class__._initialized = True
    
    def _scan_abilities(self) -> None:
        """Сканирует все файлы способностей и сохраняет классы этих способностей"""
        # Формируем путь к папке с способностями
        base_path = os.path.normpath(ABILITIES_PATH)
        
        if not os.path.exists(base_path):
            raise FileNotFoundError(f"Root folder '{base_path}' not found")
        
        for dirpath, dirnames, filenames in os.walk(base_path):
            # Пропускаем корневую директорию (где лежит abilities.py)
            if dirpath == base_path:
                continue

            for filename in filenames:
                # Исключаем служебные файлы
                if (filename.endswith('.py') and 
                    filename not in ['__init__.py', 'ability_base.py', 'abilities.py']):
                    full_path = os.path.join(dirpath, filename)
                    
                    # Загружаем класс сразу при сканировании
                    try:
                        class_name = self._get_class_name_from_file(full_path)
                        if class_name:
                            ability_class = self._load_class_from_file(full_path, class_name)
                            self._class_map[class_name] = ability_class
                    except Exception as e:
                        print(f"Warning: Failed to load ability class from '{full_path}': {str(e)}")
    
    def _get_class_name_from_file(self, file_path: str) -> Optional[str]:
        """Получает имя первого класса из файла Python"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Ищем первую строку с определением класса (только если class в начале строки)
            match = re.search(r'^class\s+(\w+)', content, re.MULTILINE)
            if match:
                return match.group(1)
            return None
        except Exception:
            return None

    def _load_class_from_file(self, file_path: str, class_name: str) -> type:

        spec = importlib.util.spec_from_file_location(class_name, file_path)
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        
        if not hasattr(module, class_name):
            raise AttributeError(f"Class '{class_name}' not found in module '{file_path}'")
            
        return getattr(module, class_name)
    
    def get_class(self, class_name: str) -> type:
        """Получает класс способности по имени"""
        if class_name not in self._class_map:
            available_abilities = list(self._class_map.keys())
            raise FileNotFoundError(f"Ability class '{class_name}' not found. Available abilities: {available_abilities}")
        
        return self._class_map[class_name]
    
    def get_available_abilities(self) -> List[str]:
        """Возвращает список доступных имен способностей"""
        return list(self._class_map.keys())
    
    @classmethod
    def get_instance(cls) -> 'AbilityLoader':
        """Получить экземпляр singleton"""
        if cls._instance is None:
            cls._instance = cls()
        return cls._instance

# === Система управления способностями персонажа ===

class AbilityManager:
    """Менеджер способностей персонажа"""
    
    def __init__(self) -> None:
        # Разделяем активные и пассивные способности
        self.active_abilities: Dict[str, ActiveAbility] = {}  # {name: ActiveAbility instance}
        self.passive_abilities: Dict[str, PassiveAbility] = {}  # {name: PassiveAbility instance}
        # Получаем singleton instance AbilityLoader
        self.ability_loader: AbilityLoader = AbilityLoader.get_instance()
        # Добавляем базовые способности по умолчанию
        self.add_ability_by_name('Attack')
        self.add_ability_by_name('Rest')
    
    def add_ability(self, name: str, ability_instance: Union[ActiveAbility, PassiveAbility]) -> bool:
        """Добавляет способность персонажу."""
        try:
            # Создаем копию способности для каждого персонажа
            if hasattr(ability_instance, '__class__'):
                new_ability = ability_instance.__class__()
                # Копируем все атрибуты
                for attr, value in ability_instance.__dict__.items():
                    setattr(new_ability, attr, value)
            else:
                new_ability = ability_instance
                
            # Добавляем в соответствующий словарь
            if isinstance(new_ability, PassiveAbility):
                self.passive_abilities[name] = new_ability
            elif isinstance(new_ability, ActiveAbility):
                self.active_abilities[name] = new_ability
            return True
        except Exception as e:
            print(f"Error adding ability '{name}': {e}")
            return False
    
    def remove_ability(self, name: str) -> bool:
        """Удаляет способность по имени."""
        if name in self.active_abilities:
            del self.active_abilities[name]
            return True
        elif name in self.passive_abilities:
            del self.passive_abilities[name]
            return True
        return False
    
    def clear_abilities(self) -> None:
        """Удаляет все способности."""
        self.active_abilities.clear()
        self.passive_abilities.clear()
    
    def get_ability(self, name: str) -> Optional[Union[ActiveAbility, PassiveAbility]]:
        """Получает способность по имени."""
        if name in self.active_abilities:
            return self.active_abilities[name]
        elif name in self.passive_abilities:
            return self.passive_abilities[name]
        return None
    
    def get_active_ability(self, name: str) -> Optional[ActiveAbility]:
        """Получает активную способность по имени."""
        return self.active_abilities.get(name)
    
    def get_passive_ability(self, name: str) -> Optional[PassiveAbility]:
        """Получает пассивную способность по имени."""
        return self.passive_abilities.get(name)
    
    def get_all_abilities(self) -> List[Union[ActiveAbility, PassiveAbility]]:
        """Возвращает все способности персонажа."""
        return list(self.active_abilities.values()) + list(self.passive_abilities.values())
    
    def get_active_abilities(self) -> List[ActiveAbility]:
        """Возвращает все активные способности персонажа."""
        return list(self.active_abilities.values())
    
    def get_passive_abilities(self) -> List[PassiveAbility]:
        """Возвращает все пассивные способности персонажа."""
        return list(self.passive_abilities.values())
    
    def get_all_ability_names(self) -> List[str]:
        """Возвращает имена всех способностей персонажа."""
        return list(self.active_abilities.keys()) + list(self.passive_abilities.keys())
    
    def get_active_ability_names(self) -> List[str]:
        """Возвращает имена всех активных способностей персонажа."""
        return list(self.active_abilities.keys())
    
    def get_passive_ability_names(self) -> List[str]:
        """Возвращает имена всех пассивных способностей персонажа."""
        return list(self.passive_abilities.keys())
    
    def get_available_abilities(self, character: Any) -> List[ActiveAbility]:
        """
        Возвращает список ссылок на активные способности, которые сейчас доступны.
        :param character: Персонаж для проверки условий
        :return: Список доступных способностей (ActiveAbility instances)
        """
        return [ability for ability in self.active_abilities.values() if ability.can_use(character)]
    
    def get_available_ability_names(self, character: Any) -> List[str]:
        """
        Возвращает список имен активных способностей, которые сейчас доступны.
        :param character: Персонаж для проверки условий
        :return: Список имен доступных способностей
        """
        return [name for name, ability in self.active_abilities.items() if ability.can_use(character)]
    
    def get_available_passive_abilities(self, character: Any) -> List[PassiveAbility]:
        """
        Возвращает список ссылок на пассивные способности, которые сейчас доступны.
        :param character: Персонаж для проверки условий
        :return: Список доступных пассивных способностей (PassiveAbility instances)
        """
        return [ability for ability in self.passive_abilities.values() if ability.is_available()]
    
    def use_ability(self, ability: Optional[ActiveAbility], character: Any, 
                   targets: List[Any], **kwargs: Any) -> AbilityResult:
        """Использует активную способность напрямую."""
        if ability and isinstance(ability, ActiveAbility) and ability.can_use(character, targets):
            return ability.use(character, targets, **kwargs)
        result = AbilityResult()
        result.success = False
        result.reason = "Способность недоступна или не является активной"
        return result
    
    def update_cooldowns(self) -> None:
        """Обновляет кулдауны всех активных способностей в конце раунда."""
        for ability in self.active_abilities.values():
            if hasattr(ability, 'update_cooldown'):
                ability.update_cooldown()

    def reset_all_cooldowns(self) -> None:
        """Сбрасывает все кулдауны активных способностей до 0."""
        for ability in self.active_abilities.values():
            if hasattr(ability, 'current_cooldown'):
                ability.current_cooldown = 0
    
    def create_ability_by_name(self, ability_name: str) -> Optional[Union[ActiveAbility, PassiveAbility]]:
        """
        Создает экземпляр способности по имени через AbilityLoader.
        
        :param ability_name: Имя способности (должно совпадать с именем класса)
        :return: Экземпляр способности или None, если не найдена
        """
        try:
            ability_class = self.ability_loader.get_class(ability_name)
            return ability_class()
        except (FileNotFoundError, ImportError, AttributeError) as e:
            print(f"Ошибка при создании способности '{ability_name}': {e}")
            return None
    
    def add_ability_by_name(self, ability_name: str) -> bool:
        """
        Добавляет способность по имени.
        
        :param ability_name: Имя способности для добавления
        :return: True, если успешно добавлена, False в случае ошибки
        """
        ability_instance = self.create_ability_by_name(ability_name)
        if ability_instance:
            # Используем имя файла (в нижнем регистре) как ключ
            name_key = ability_name.lower()
            return self.add_ability(name_key, ability_instance)
        return False
    
    def level_up_ability(self, ability_name: str) -> int:
        """
        Повышает уровень способности на 1.
        
        :param ability_name: Имя способности
        :return: Новый уровень способности или -1 если способность не найдена
        """
        ability = self.get_ability(ability_name)
        if ability:
            return ability.level_up()
        return -1
    
    def set_ability_level(self, ability_name: str, level: int) -> int:
        """
        Устанавливает уровень способности.
        
        :param ability_name: Имя способности
        :param level: Новый уровень
        :return: Новый уровень способности или -1 если способность не найдена
        """
        ability = self.get_ability(ability_name)
        if ability:
            return ability.set_level(level)
        return -1

# Удобная функция для получения AbilityLoader
def get_ability_loader() -> AbilityLoader:
    """Получить singleton экземпляр AbilityLoader"""
    return AbilityLoader.get_instance()
----------------------------------------
КОНЕЦ ФАЙЛА: ./Characters/Abilities/abilities.py
============================================================

